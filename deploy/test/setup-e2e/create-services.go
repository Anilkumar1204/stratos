package main

import (
	"time"
	"fmt"
	"io/ioutil"
	"os"
	uuid "github.com/satori/go.uuid"
	"github.com/cloudfoundry-community/go-cfclient"
	"github.com/cloudfoundry-incubator/stratos/plugins/cfapppush"
	"github.com/cloudfoundry-incubator/stratos/plugins/cfapppush/pushapp"
)

type ServiceCreator struct {
	brokerUrl string
	client    *cfclient.Client
	fixture   FixtureConfig
	endpoint  Endpoint
}

func CreateServiceCreator(cfClient *cfclient.Client, endpoint Endpoint, fixture FixtureConfig) *ServiceCreator {

	return &ServiceCreator{
		brokerUrl: "https://github.com/irfanhabib/worlds-simplest-service-broker",
		client:    cfClient,
		fixture:   fixture,
		endpoint:  endpoint,
	}

}

func (this *ServiceCreator) createBrokerApp(serviceName string, baseGUID string) (string, error) {

	tempDir, err := ioutil.TempDir("", "cf-push-")
	if err != nil {
		return "", fmt.Errorf("Failed to create tmp dir due to %+v", err)
	}
	defer os.RemoveAll(tempDir)

	// Clone broker

	vcsGit := cfapppush.GetVCS()

	err = vcsGit.Create(tempDir, this.brokerUrl, "master")
	if err != nil {
		return "", fmt.Errorf("Failed to clone due to %+v", err)
	}

	orgEntity, err := this.client.GetOrgByName(this.fixture.Organization)
	if err != nil {
		return "", err
	}

	spaceEntity, err := this.client.GetSpaceByName(this.fixture.Space, orgEntity.Guid)
	if err != nil {
		return "", err
	}
	pushConfig, err := this.getPushConfig(orgEntity.Guid, spaceEntity.Guid)
	if err != nil {
		return "", fmt.Errorf("Failed to create push config")
	}

	cfPush := pushapp.Constructor(pushConfig)

	appName := fmt.Sprintf("%s-broker", serviceName)
	cfPush.Init(tempDir, fmt.Sprintf("%s/manifest.yaml", tempDir), []pushapp.PushArg{
		pushapp.PushArg{
			Flag: fmt.Sprintf("%s-broker", serviceName),
			NoArg: true
		}
		pushapp.PushArg{
			Flag:  "--no-start",
			NoArg: true,
		},
		pushapp.PushArg{
			Flag:  "-m",
			Value: "-128M",
			NoArg: false,
		},
		pushapp.PushArg{
			Flag:  "-k",
			Value: "256M",
			NoArg: false,
		},
	})

	// Push Broker
	err = cfPush.Push()
	if err != nil {
		return "", fmt.Errorf("Failed to push app due to %s", err)
	}

	appEntity, err := this.client.AppByName(appName, spaceEntity.Guid, orgEntity.Guid)
	if err != nil {
		return "", fmt.Errorf("Failed to get app due to %s", err)
	}
	// Configure Broker
	this.setEnvVar(appEntity.Guid, "BASE_GUID", baseGUID )
	this.setEnvVar(appEntity.Guid, "CREDENTIALS", "{\"port\": \"4000\", \"host\": \"1.2.3.4\"}" )
	this.setEnvVar(appEntity.Guid, "SERVICE_NAME", serviceName )
	this.setEnvVar(appEntity.Guid, "SERVICE_PLAN_NAME", "shared" )
	this.setEnvVar(appEntity.Guid, "TAGS", "simple,shared" )

	// Start
	this.setAppState(appEntity.Guid, "STARTED")

	// Wait till broker is started

	for {
		app, err := this.client.AppByGuid(appEntity.Guid)
		if app.State != "STARTED"{
			time.Sleep(10 * time.Second)
		} else {
			break
		}
	}

	app, err := this.client.AppByGuid(appEntity.Guid)
	serviceURL = app.Environment["SERVICE_URL"]
	return serviceURL, nil

}

type ServiceVisibility struct {
	// Space scoped
	SpaceScoped bool
	SpaceGUID string
	// Privately scoped
	Private bool
	OrgGuid string

}
func (this *ServiceCreator) CreateService(serviceName string, visibility ServiceVisibility) {

	baseGUID = uuid.NewV4().String()
	serviceURL, err := createBrokerApp(serviceName, baseGUID)
	this.client.CreateServiceBroker(cfclient.CreateServiceBrokerRequest{
		Name: serviceName,
		BrokerURL: serviceURL,
		Username: "admin",
		Password: "admin",
		SpaceGUID: visibility.SpaceGUID
	}
)

// Set visibility
if visibility.SpaceScoped {
	// Nothing needs to be done
	if visibility.SpaceGUID == "" {
		return fmt.Errorf("To create a space scoped service, please provide a space guid")
	}
}

// Private service
if visibility.Private {
	if visibility.OrgGuid == "" {
		return fmt.Errorf("To create a private service, please provide an org guid")
	}

}



}

func (this *ServiceCreator) createServiceVisibility(serviceName string, orgGuid string){
	// This name is determinstically generated by the `worlds-simplest-service-broker`
	servicePlanID = fmt.Sprintf("%-plan-shared", baseGUID)


}
func (this *ServiceCreator) setEnvVar(appGuid string, key string, value string) error {


	appEnv, err := this.client.GetAppEnv(appGuid)
	if err != nil {
		return fmt.Errorf("Failed to get env vars for app due to %s", err)
	}

	envJson := appEnv.Environment
	envJson[key] = value
	_, err = this.client.UpdateApp(appGuid, cfclient.AppUpdateResource{
		Environment: envJson
	})
	if err != nil {
		return fmt.Errorf("Failed to update env vars for app due to %s", err)
	}

	return nil
}

func (this *ServiceCreator) setAppState(appGuid string, state string) error {
	_, err = this.client.UpdateApp(appGuid, cfclient.AppUpdateResource{
		State: state
	})
	return err
}
func (this *ServiceCreator) getPushConfig(orgGuid string, spaceGuid string) (*pushapp.CFPushAppConfig, error) {

	info, err := this.client.GetInfo()
	if err != nil {
		return nil, err
	}

	token, err := this.client.Config.TokenSource.Token()
	if err != nil {
		return nil, fmt.Errorf("Unable to get token")
	}

	config := &pushapp.CFPushAppConfig{
		AuthorizationEndpoint:  info.AuthorizationEndpoint,
		CFClient:               this.endpoint.UAA.CFClient,
		CFClientSecret:         this.endpoint.UAA.CFClientSecret,
		APIEndpointURL:         this.endpoint.URL,
		DopplerLoggingEndpoint: info.DopplerLoggingEndpoint,
		SkipSSLValidation:      this.endpoint.SkipSSLValidation,
		AuthToken:              fmt.Sprintf("bearer %s", token.AccessToken),
		RefreshToken:           token.RefreshToken,
		OrgGUID:                orgGuid,
		OrgName:                this.fixture.Organization,
		SpaceGUID:              spaceGuid,
		SpaceName:              this.fixture.Space,
		OutputWriter:           ioutil.Discard,
		DialTimeout:            "",
	}
	return config, nil
}
